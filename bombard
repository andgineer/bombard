#!/usr/bin/env python3
"""
Send stress requests to show multi-processing Db problem
"""
from threading import Thread
import http.client
import sys
from queue import Queue
from urllib.parse import urlparse
import ssl
import json
import yaml
import os.path


THREADS_NUM = 50
queue: Queue= None


def do_work():
    while True:
        job = queue.get()
        status = make_request(job['request'])['status']
        report(status, job)
        queue.task_done()


def report(status, job):
    print(job['id'], '<' * 6, status)


def apply_context(request: dict, context: dict) -> dict:
    """
    Use context to substitute all {name} in request strings.
    """
    for name in request:
        if isinstance(request[name], dict):
            request[name] = apply_context(request[name], context)
        if isinstance(request[name], str):
            request[name] = request[name].format(**context)
    return request


def make_request(request: dict) -> dict:
    """
    Make HTTP request described in request.
    Returns dict with names extracted from request result if 'extract' part is specified in the request.
    And place 'status' or the response to the dict.
    """
    url = urlparse(request['url'])
    conn = http.client.HTTPSConnection(
        url.netloc,
        context=ssl._create_unverified_context()
    )
    conn.request(
        request['method'],
        url.path,
        body=json.dumps(request['body']) if 'body' in request else None,
        headers=request['headers'] if 'headers' in request else {}
    )
    resp = conn.getresponse()
    result = {'status': resp.status}
    if 'extract' in request:
        data = json.loads(resp.read())
        for name, val in request['extract'].items():
            if not val:
                val = name
            result[name] = data[val]
    return result


def set_up(play_book: dict):
    """
    Execute HTTP requests from play book (presumably loaded from setUp section of yaml definitions).
    Returns dict with names extracted from the requests results
    """
    result = {}
    for request in play_book.values():
        result.update(make_request(request))
    return result


def main(requests_file_name: str):
    global queue
    play_book = yaml.full_load(open(requests_file_name, 'r'))
    context = play_book['vars']
    set_up_requests = apply_context(play_book['setUp'], context)
    context.update(set_up(set_up_requests))
    bombard_requests = apply_context(play_book['bombard'], context)

    queue = Queue(THREADS_NUM)
    for i in range(THREADS_NUM):
        t = Thread(target=do_work)
        t.daemon = True
        t.start()

    try:
        for request in bombard_requests.values():
            for _ in range(request.get('repeat', 1)):
                queue.put({'id': queue.qsize(), 'request': request})
        queue.join()
    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) > 1:
        if not os.path.isfile(sys.argv[1]):
            print(f'''bombard: utility to bombard with HTTP-requests.
Usage: bombard <requests-file> (default bombard.yaml in current folder).

(!) Cannot find requests file "{sys.argv[1]}."            
''')

            exit(1)
        main(sys.argv[1])
    else:
        main('bombard.yaml')
