#!/usr/bin/env python3
"""
Send stress requests to show multi-processing Db problem
"""
import sys
import os.path
from urllib.parse import urlparse
from threading import Thread
import http.client
from queue import Queue
import ssl
import json
import argparse
import yaml


THREADS_NUM = 50
REQUESTS_FILE_NAME = 'bombard.yaml'
queue: Queue= None


def do_work():
    while True:
        job = queue.get()
        status = make_request(job['request'])['status']
        report(status, job)
        queue.task_done()


def report(status, job):
    print(job['id'], '<' * 6, status)


def apply_context(request: dict, context: dict) -> dict:
    """
    Use context to substitute all {name} in request strings.
    """
    for name in request:
        if isinstance(request[name], dict):
            request[name] = apply_context(request[name], context)
        if isinstance(request[name], str):
            request[name] = request[name].format(**context)
    return request


def make_request(request: dict) -> dict:
    """
    Make HTTP request described in request.
    Returns dict with names extracted from request result if 'extract' part is specified in the request.
    And place 'status' or the response to the dict.
    """
    url = urlparse(request['url'])
    conn = http.client.HTTPSConnection(
        url.netloc,
        context=ssl._create_unverified_context()
    )
    conn.request(
        request['method'],
        url.path,
        body=json.dumps(request['body']) if 'body' in request else None,
        headers=request['headers'] if 'headers' in request else {}
    )
    resp = conn.getresponse()
    result = {'status': resp.status}
    if 'extract' in request:
        data = json.loads(resp.read())
        for name, val in request['extract'].items():
            if not val:
                val = name
            result[name] = data[val]
    return result


def set_up(play_book: dict):
    """
    Execute HTTP requests from play book (presumably loaded from setUp section of yaml definitions).
    Returns dict with names extracted from the requests results
    """
    result = {}
    for request in play_book.values():
        result.update(make_request(request))
    return result


def get_args():
    parser = argparse.ArgumentParser(
        description='bombard: utility to bombard with HTTP-requests.'
    )
    parser.add_argument(
        dest='file_name', type=str, nargs='?',
        default=REQUESTS_FILE_NAME,
        help=f'requests file name (default "{REQUESTS_FILE_NAME}")'
    )
    parser.add_argument(
        '--threads', dest='threads', type=int,
        default=THREADS_NUM,
        help=f'number of threads (default {THREADS_NUM})'
    )
    parser.add_argument(
        '--var', dest='vars', type=str, nargs='*',
        help='vars as "name=val"'
    )
    return parser.parse_args()


def main():
    global queue
    args = get_args()
    if not os.path.isfile(args.file_name):
            print(f'(!) Cannot find requests file "{args.file_name}."')
            exit(1)
    play_book = yaml.full_load(open(args.file_name, 'r'))
    if args.vars:
        context = dict([var.split('=') for var in args.vars])
    else:
        context = {}
    for var, val in play_book['vars'].items():
        if var not in context:
            context[var] = val.format(**context)
    print(f'Use vars: {context}')
    set_up_requests = apply_context(play_book['setUp'], context)
    context.update(set_up(set_up_requests))
    bombard_requests = apply_context(play_book['bombard'], context)

    queue = Queue(args.threads)
    for i in range(args.threads):
        t = Thread(target=do_work)
        t.daemon = True
        t.start()

    try:
        for request in bombard_requests.values():
            for _ in range(request.get('repeat', 1)):
                queue.put({'id': queue.qsize(), 'request': request})
        queue.join()
    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == '__main__':
        main()
