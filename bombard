#!/usr/bin/env python3
"""
Send stress requests to show multi-processing Db problem
"""
import sys
import os.path
from urllib.parse import urlparse
from threading import Thread
import http.client
from queue import Queue
import ssl
import json
import argparse
import yaml


THREADS_NUM = 100
REQUESTS_FILE_NAME = 'bombard.yaml'
REPEAT = 100
OK = [200]
OVERLOAD_ERROR = [502, 504]


semaphore: Queue= None


def do_work(thread_id):
    def green(s: str) -> str:
        return f'\033[1;32;40m{s}\033[0;37;40m'

    def red(s: str) -> str:
        return f'\033[1;31;40m{s}\033[0;37;40m'

    def dark_red(s: str) -> str:
        return f'\033[0;31;40m{s}\033[0;37;40m'

    def status_coloured(status: int) -> str:
        if status in OK:
            return green(str(status))
        elif status in OVERLOAD_ERROR:
            return dark_red(str(status))
        else:
            return red(str(status))

    while True:
        job = semaphore.get()
        status = make_request(job['request'])['status']
        print(f'{job["id"]} (thread {thread_id}) ', '<' * 6, status_coloured(status))
        semaphore.task_done()


def apply_context(request: dict, context: dict) -> dict:
    """
    Use context to substitute all {name} in request strings.
    """
    for name in request:
        if isinstance(request[name], dict):
            request[name] = apply_context(request[name], context)
        if isinstance(request[name], str):
            request[name] = request[name].format(**context)
    return request


def make_request(request: dict) -> dict:
    """
    Make HTTP request described in request.
    Returns dict with names extracted from request result if 'extract' part is specified in the request.
    And place 'status' or the response to the dict.
    """
    url = urlparse(request['url'])
    conn = http.client.HTTPSConnection(
        url.netloc,
        context=ssl._create_unverified_context()
    )
    conn.request(
        request['method'],
        url.path,
        body=json.dumps(request['body']) if 'body' in request else None,
        headers=request['headers'] if 'headers' in request else {}
    )
    resp = conn.getresponse()
    result = {'status': resp.status}
    if 'extract' in request:
        data = json.loads(resp.read())
        for name, val in request['extract'].items():
            if not val:
                val = name
            result[name] = data[val]
    return result


def set_up(play_book: dict):
    """
    Execute HTTP requests from play book (presumably loaded from setUp section of yaml definitions).
    Returns dict with names extracted from the requests results
    """
    result = {}
    for request in play_book.values():
        result.update(make_request(request))
    return result


def get_args():
    parser = argparse.ArgumentParser(
        description='bombard: utility to bombard with HTTP-requests.'
    )
    parser.add_argument(
        dest='file_name', type=str, nargs='?',
        default=REQUESTS_FILE_NAME,
        help=f'requests file name (default "{REQUESTS_FILE_NAME}")'
    )
    parser.add_argument(
        '--threads', dest='threads', type=int,
        default=THREADS_NUM,
        help=f'number of threads (default {THREADS_NUM})'
    )
    parser.add_argument(
        '--var', '-v', dest='vars', type=str, nargs='*',
        help='vars as "name=val"'
    )
    parser.add_argument(
        '--repeat', '-r', dest='repeat', type=int, default=REPEAT,
        help=f'how many times to repeat (by defaul {REPEAT})'
    )
    return parser.parse_args()


def main():
    global semaphore
    args = get_args()
    if not os.path.isfile(args.file_name):
            print(f'(!) Cannot find requests file "{args.file_name}."')
            exit(1)
    play_book = yaml.full_load(open(args.file_name, 'r'))
    if args.vars:
        context = dict([var.split('=') for var in args.vars])
    else:
        context = {}
    for var, val in play_book['vars'].items():
        if var not in context:
            context[var] = val.format(**context)
    print(f'Use vars: {context}')
    set_up_requests = apply_context(play_book['setUp'], context)
    context.update(set_up(set_up_requests))
    bombard_requests = apply_context(play_book['bombard'], context)

    semaphore = Queue(args.threads)
    for i in range(args.threads):
        t = Thread(target=do_work, args=[i])
        t.daemon = True
        t.start()

    try:
        request_id = 0
        for counter in range(args.repeat):
            for request in bombard_requests.values():
                for _ in range(request.get('repeat', 1)):
                    semaphore.put({'id': request_id, 'request': request})
                    request_id += 1
        semaphore.join()
    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == '__main__':
        main()
