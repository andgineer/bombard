# Файл кампании

Все разделы не являются обязательными.

Но вам нужен раздел `prepare` или `ammo`, так что Bombard выполнит несколько запросов.

Везде, где вы можете использовать выражения Python `{}`, например:

```python
repeat: "{args.repeat * 2}"
```

Аргументы командной строки доступны как `args` в этих выражениях.
Все переменные supply доступны как глобальные.

## Параметры HTTP

Все параметры HTTP, кроме URL, являются необязательными.

```yaml
url: "{host}auth"  # полностью указанный URL
method: POST  # по умолчанию GET
body:  # ниже JSON объект для тела запроса
    email: name@example.com
    password: admin
headers:
  json:  # то же самое, что и Content-Type: "application/json"
  Authorization: "Bearer {token}"
```

## supply

Переменные, которые вы используете как `{name}` в своих запросах.
Также вы можете (пере)определить эту переменную, используя `--supply`, например:

```
bombard -s name=value,name2=value2
```

Также вы можете (пере)определить их из запросов.

Если в описании запроса есть раздел `extract`, он (пере)определит переменную `supply` с именем из этого раздела.

Раздел `script` в запросе также может (пере)определять переменные.

## Описание запроса

Вы используете эти описания в разделах `prepare` и `ammo`, описанных ниже.

Каждый запрос должен иметь `URL`, и в принципе этого достаточно.
Если вам нужно, вы можете добавить другие элементы, например:

```yaml
getToken:  # Имя запроса по вашему выбору
  repeat: "{args.repeat * 2}"  # по умолчанию - опция --repeat
  url: "{host}auth"  # мы используем переменную supply.base
  method: POST  # по умолчанию GET
  headers: json  # сокращение для Content-Type: application/json
  body:  # JSON объект для тела запроса
    email: admin@example.com
    password: admin
  extract:  # извлечь из результата запроса и добавить в supply
    token:
```

Bombard автоматически добавляет `application/json` в headers, если в запросе указано тело JSON.
Если вам нужно другое значение `Content-Type`, просто добавьте его в раздел `headers`, и оно переопределит значение по умолчанию.

### repeat

Переопределяет опцию командной строки `--repeat`. Количество повторений для запроса.

### script

В запросе вы можете добавить раздел `script` с кодом Python3.
Он запускается после запроса.

Он может использовать объект `supply` и запускать запросы с функцией `reload`.
Определения запросов из раздела `ammo` доступны как `ammo.request_name`.

Ответ на запрос доступен в объекте `resp`.

В приведенном ниже примере мы запускаем запросы `getPost` из раздела `ammo` для первых трех постов, которые мы получаем в ответе:

```python
for post in resp[:3]:
  reload(ammo.getPost, id=post['id'])
```

Также вы можете поместить код Python в отдельный файл и использовать его следующим образом:

```yaml
script: !include get_token.py
```

Если вы добавите эту строку, она проверяет все необходимые объекты, и вы можете использовать автозаполнение кода в вашей IDE:

```python
from bombard.mock_globals import *; master('path/to/you/yaml')
```

### extract

Вместо скрипта вы можете использовать раздел `extract` в запросе.
Он может содержать карту пар `name: extract`. Для каждой пары
Bombard будет (пере)определять переменную `supply` с именем `name` со
значением, извлеченным из ответа на запрос как `['extract']`.

```yaml
extract:
    name: extract
    name2: extract2
```

Если `extract` пусто, Bombard будет использовать `name`, поэтому
`name:` совпадает с `name: name`.

Также вы можете использовать любые пользовательские индексы, которые вы хотите, например

```yaml
extract:
    token: "['data']['JWT']"  # поместить resp['data']['JWT'] в supply.token
```

поэтому `name: ['name']` совпадает с `name:`.

### dry

Если вы запускаете Bombard с `--dry`, он не делает реальных HTTP-запросов.
И если у вас есть раздел `dry` в запросе, Bombard будет использовать его как
результат этого `dry` запроса.

## prepare

Если в файле кампании есть этот раздел, Bombard начнет выполнение с запросов
из этого раздела.

Запросы в этом разделе могут запускать запросы из раздела `ammo`, например:

```yaml
prepare:
  postsList:  # Получить идентификаторы постов
    url: "{host}posts"
    script: |
      for post in resp[:3]:  # запустить ammo.getPost для первых трех постов в списке
        reload(ammo.getPost, id=post['id'])
```

Как вы видите выше, вы можете отправить некоторую переменную не только
глобальному `supply`, но и просто в запрос, который вы запускаете.

Если раздел `prepare` не запустил никаких запросов `ammo`, Bombard после
`prepare` запустит все запросы из раздела `ammo`.

Итак, если у вас есть только разделы `extract` в запросах `prepare`.
Или если `scripts` в запросах `prepare` не вызывают `reload` для запуска
запросов из `ammo`. Тогда Bombard запустит все запросы `ammo`
после запросов `prepare`.

## ammo

Если в файле кампании нет раздела `prepare`, Bombard просто запустит все
запросы из этого раздела.

Каждый запрос будет повторяться `--repeat` раз, как указано в командной
строке (или по умолчанию для этой опции).

В противном случае Bombard запустит раздел `prepare`, и после этого, если
запросы `prepare` не запустили никаких запросов из `ammo`, Bombard запустит все
запросы из `ammo`.

Пример запроса `ammo` для запроса, который вы видите в разделе `prepare`:

```yaml
ammo:
  getPost:
    url: "{host}posts/{id}"  # использует {host} из глобального supply и {id} из локального supply только для этого запроса - см. скрипт выше
```